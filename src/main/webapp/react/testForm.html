<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="UTF-8">
	<title>Hello React</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/react.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/react/0.13.3/JSXTransformer.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.2/marked.min.js"></script>
</head>
<body>
<div id="content"></div>
<script type="text/jsx">
	var CommentForm = React.createClass({
		handleSubmit: function(e) {
			e.preventDefault();
			var author = React.findDOMNode(this.refs.author).value.trim();
			var text = React.findDOMNode(this.refs.text).value.trim();
			if (!text || !author) {
				return;
			}

			// 서버에 요청을 전송합니다
			this.props.onCommentSubmit({author: author, text: text});

			React.findDOMNode(this.refs.author).value = '';
			React.findDOMNode(this.refs.text).value = '';
			return;
		},
		render: function() {
		return (
				<form className="commentForm" onSubmit={this.handleSubmit}>
					<input type="text" placeholder="이름" ref="author" />
					<input type="text" placeholder="내용을 입력하세요..." ref="text" />
					<input type="submit" value="올리기" />
				</form>
		);
	}
	});

	var Comment = React.createClass({
		render: function() {
			var rawMarkup = marked(this.props.children.toString(), {sanitize: true});
			return (
					<div className="comment">
						<h2 className="commentAuthor">
							{this.props.author}
						</h2>
						<span dangerouslySetInnerHTML={{__html: rawMarkup}} />
					</div>
			);
		}
	});

	var CommentList = React.createClass({
		render: function() {
			if (this.props.data) {
				var commentNodes = this.props.data.map(function (comment) {
					return (
							<Comment author={comment.author}>
								{comment.text}
							</Comment>
					);
				});
			}
			return (
					<div className="commentList">
						{commentNodes}
					</div>
			);
		}
	});

	var CommentBox = React.createClass({
		loadCommentsFromServer: function() {
			$.ajax({
				url: this.props.url,
				dataType: 'json',
				cache: false,
				success: function(data) {
					this.setState({data: data});
				}.bind(this),
				error: function(xhr, status, err) {
					console.error(this.props.url, status, err.toString());
				}.bind(this)
			});
		},
		handleCommentSubmit: function(comment) {
			//먼저 화면에 추가하고, 서버로 ajax 요청을 보낸다.
			var comments = this.state.data;
			var newComments = comments.concat([comment]);
			this.setState({data: newComments});

			$.ajax({
				url: "/hello/saveData", //this.props.url,
				dataType: 'json',
				type: 'POST',
				data: comment,
				success: function(data) {
					this.setState({data: data});
				}.bind(this),
				error: function(xhr, status, err) {
					console.error(this.props.url, status, err.toString());
				}.bind(this)
			});
		},
		getInitialState: function() {
			return {data: []};
		},
		componentDidMount: function() {
			this.loadCommentsFromServer();
			setInterval(this.loadCommentsFromServer, this.props.pollInterval);
		},
		render: function() {
			return (
					<div className="commentBox">
						<h1>댓글</h1>
						<CommentList data={this.state.data} />
						<CommentForm onCommentSubmit={this.handleCommentSubmit} />
					</div>
			);
		}
	});

	React.render(
			<CommentBox url="/hello/getData" pollInterval={2000} />,
			document.getElementById('content')
	);
</script>
<!--
0. 리엑트 한글 레퍼런스 사이트 : http://reactkr.github.io/react/docs/tutorial-ko-KR.html
1. 받을때 prop, 보내때 state
2. getInitialState() 는 컴포넌트의 생명주기동안 한 번만 실행되며 컴포넌트의 초기 state를 설정합니다.
3. componentDidMount는 컴포넌트가 렌더링 된 다음 React에 의해 자동으로 호출되는 메소드입니다. 동적 업데이트의 핵심은 this.setState()의 호출입니다.
   우리가 이전의 댓글 목록을 서버에서 넘어온 새로운 목록으로 변경하면 자동으로 UI가 업데이트 될 것입니다. 이 반응성 덕분에 실시간 업데이트에 아주
   작은 수정만 가해집니다.
4.
-->
</body>
</html>
  